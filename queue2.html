<!DOCTYPE html>
<html>
<head>
<title>queue2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>wait-free queue protocol for 2 threads</h1>
<p>2015.06.21.</p>
<h2>Overview</h2>
<p>The protocol is based on a <strong>gentle coordination</strong> scheme. In case the thread detects that the other thread is active, it gently offers the position for it.</p>
<p>Details:</p>
<ol>
<li><strong>Actual pos</strong> - Read the actual queue position</li>
<li><strong>Is other active?</strong> - Check whether the other thread is active</li>
<li>
<strong>Determine the next positions</strong> - depending on whether the other thread is active or not:
<ol>
<li>If the other queue is not active, then the next position will be the actual + 1 and do not offer anything</li>
<li>
If the other queue is active, then 
<ol>
<li>if there was a previous offer then the next position will be the actual + 1 and reoffer the previous offer, </li>
<li>if there was no previous offer, then the next positionn will be the actual pos + 2 and offer the actual pos + 1.</li>
</ol>
</li>
</ol>
</li>
<li><strong>Try to set the next positions</strong> - set the above numbers using CAS</li>
<li><strong>Use my number if we won, use the offer otherwise</strong> - If the set was successful then we are DONE. If the set was unseccessful then accept the offer made by the other thread. If there was no offer then use the actual pos + 1 </li>
</ol>
<p>Premisse: The protocol builds on the <code>compare-and-set</code> (<code>CAS</code>) primitive and <code>volatile</code> fields (that is always read from main memory). These should be supported by the underlying platform (for instance Java does support them).</p>
<h2>States</h2>
<p>The protocol has the following states:</p>
<ul>
<li><code>active_0, active_1 : boolean</code> - two flags that show whether thread 0, thread 1 is active or not. A thread is <em>active</em> if it is just enqueueing.</li>
<li>
<code>actual : struct(last : int, last_offered: int)</code> - a struct that shows the actual positions
<ul>
<li><code>pos</code> - the actual queue position, ie. the position in the queue where the last item was pushed</li>
<li><code>offer_0, offer_1</code> - the last position the thread offered for the other thread</li>
</ul>
</li>
</ul>
<h2>Protocol</h2>
<h3>1 actual numbers</h3>
<pre><code>volatile v_actual := actual
v_pos := actual.pos
v_offer := actual.offer_my_index
</code></pre>

<p>, where <code>my_index</code> is the index of the thread (0 or 1)</p>
<p>Premisse: data is read from main memory, not from CPU cache</p>
<h3>2 is other thread active?</h3>
<pre><code>volatile v_other_active := active_its_index
</code></pre>

<p>, where </p>
<pre><code>its_index = my_index + 1 % 2
</code></pre>

<p>Premisse: data is read from main memory, not from CPU cache</p>
<h3>3 determine next positions</h3>
<h4>3.1 other is not active</h4>
<pre><code>if not v_other_active then
    v_next := v_actual + 1
    v_next_offer := undefined
</code></pre>

<h4>3.2 other is active</h4>
<pre><code>if v_other_active then
</code></pre>

<h5>3.2.1 there was no previous offer</h5>
<pre><code>if v_offer is undefined then:
    next_pos := pos + 2
    next_offer := pos + 1
</code></pre>

<h5>3.2.2 there was a previous offer</h5>
<pre><code>if v_offer is defined then:
    next_pos := pos + 1
    next_offer := offer
</code></pre>

<h5>store it</h5>
<pre><code>v_next.pos := next_pos
v_next.offer_my_index := offer
v_next.offer_her_index := undefined
</code></pre>

<h3>4 try to set next positions</h3>
<pre><code>set_succeeded := actual.compare_and_set(v_actual, v_next)    
</code></pre>

<p>Premisse: either thread wins, that is it does not happen that both fails.</p>
<h3>5 use my number if won and accept her offer otherwise</h3>
<h4>5.1 use my number if won</h4>
<pre><code>if set_succeeded then
    return next_pos
</code></pre>

<h4>5.1 use her offer if lost</h4>
<pre><code>if not set_succeeded then
    v_actual := actual
    pos := actual.pos
    offer := actual.offer_its_index
    return offer defined ? offer : pos + 1 
</code></pre>

<p>Premisse: data is read from main memory, not from CPU cache</p>
<h2>Features</h2>
<p>To my beleif the above protocol provides the above features/guarantees:</p>
<ol>
<li>it is consistent with the queueing protocols - the same position is never overwritten, the protocol does not introduce holes in the queue</li>
<li>it is wait-free/fair - queueing is guaranteed to finish in finite steps even in race condition, typically the thread can enqueue its item to the next position or to the next position + 1</li>
</ol>
<h2>TODO</h2>
<ul>
<li>Queues are typically not infinite, instead they use circular positons - this might cause problem.</li>
<li>In case of a slow thread a gentle offer could mean that the queue as a whole (and its consumers) should wait for the slow thread. This could be solved if the other thread repeat the enqueueing procedure of the other thread. It is slower but more reliable.</li>
</ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
